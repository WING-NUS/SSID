=begin
This file is part of SSID.

SSID is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

SSID is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with SSID.  If not, see <http://www.gnu.org/licenses/>.
=end

require 'zip'
require 'open3'

class ReorgBot

  attr_accessor :path
  attr_accessor :dir

  def initialize(path)
    raise ArgumentError, "path '#{path}' does not exist!" unless File.exist?(path)
    raise ArgumentError, "path '#{path} is not a directory you dolt!" unless File.directory?(path)
    @path = path
    @dir = Dir.new(path)
  end

  def dirs
    @dir.select { |f| File.directory?(File.join(@path, f)) }
  end

  def empty_dirs
    dirs.select { |d| Dir[File.join(@path, d, '*')].empty? }
  end

  def non_empty_dirs
    dirs - empty_dirs
  end

  def remove_empty_dirs
    log = [];
    empty_dirs.each do |d|
      FileUtils.rm_rf(File.join(@path, d))
      log << %Q{[#{Time.now.in_time_zone}] Deleting directory: #{File.join(@path, d)}}
    end
    log
  end
end

module SubmissionsHandler

  # Params for data truncation
  MAX_DATA_CHAR_SIZE = 64000
  DATA_TRUNCATE_MSG = "... (Data  got truncated)"

  def self.process_upload(file, references, isMapEnabled, mapfile, assignment)
    submissions_dir = File.join(".", "upload", assignment.id.to_s)

    # Clear upload dir if exists
    FileUtils.remove_dir submissions_dir if File.exist? submissions_dir

    # Create upload dir
    FileUtils.mkdir_p(submissions_dir)

    # Keep log
    upload_log = []
    upload_log << assignment.upload_log.truncate(MAX_DATA_CHAR_SIZE, separator: ' ', omission: DATA_TRUNCATE_MSG) if assignment.upload_log
    upload_log << %Q{[#{Time.now.in_time_zone}] Received file: #{file.original_filename}}

    # Rename upload to original file name
    submissions_file = File.join(submissions_dir, file.original_filename)

    # Move upload into dir
    FileUtils.copy_entry(file.path, submissions_file)

    submissions_extract_and_sanitize_log = extract_and_sanitize_zips(submissions_file, submissions_dir)
    
    # If references are uploaded, initialize needful folder and move references zip file over
    references_dir, references_file = nil, nil
    if references
      references_dir = File.join(submissions_dir, "references")
      FileUtils.mkdir_p(references_dir)
      references_file = File.join(references_dir, references.original_filename)
      FileUtils.copy_entry(references.path, references_file)
      references_extract_and_sanitize_log = extract_and_sanitize_zips(references_file, references_dir)
    end


    # Save log
    upload_log << submissions_extract_and_sanitize_log
    upload_log << references_extract_and_sanitize_log
    upload_log << %Q{[#{Time.now.in_time_zone}] Unzip complete}
    assignment.upload_log = upload_log.join("\n")
    assignment.save

    # Move map file (if uploaded by user) into dir	
    if (isMapEnabled)		
      upload_map_file = File.join(submissions_dir, "mapfile.csv")	
      FileUtils.copy_entry(mapfile.path, upload_map_file)	
    end	

    # Remove zip file
    FileUtils.rm submissions_file, force: true
    FileUtils.rm references_file, force: true if references

    # Return path to dir
    submissions_dir
  end

  def self.extract_and_sanitize_zips(file, path)
    puts "---debug---"
    puts "Called extract_and_sanitize_zips with"
    puts file
    puts path
    puts "---end debug---"

    accepted_extensions = [".ipynb", ".py",".java", ".cpp", ".c", ".h", ".scala", ".m", ".ml", ".mli", ".r"]

    # Regexes for special characters (emojis etc.) be removed
    regexes_to_remove = [/[\u{1f600}-\u{1f64f}]/,/[\u{2702}-\u{27b0}]/,/[\u{1f680}-\u{1f6ff}]/,/[\u{24C2}-\u{1F251}]/,/[\u{1f300}-\u{1f5ff}]/]

    extract_and_sanitize_zips_log = []

    # check zip file
    has_entry_same_name_with_submissions_file = false
    submissions_file_without_ext = File.basename(file, ".zip") + File::SEPARATOR

    # Extract submissions into dir
    Zip::File.open(file) { |zip_file|
      zip_file.each { |f|

      file_entry_names = zip_file.entries.collect {|file| file.name}
      file_entry_names.each { |file_name|
        if (file_name.eql?(submissions_file_without_ext)) 
          has_entry_same_name_with_submissions_file = true
        end
      }

      if has_entry_same_name_with_submissions_file
        return false
      end

      # isdirectory or filter by accepted file extension. Skip __MACOSX/* and .DS_Store generated by Mac.
      if (not f.name.match? /__MACOSX\/|.DS_Store/) and (File.directory?(f.name) or accepted_extensions.include? File.extname(f.name))
        extract_and_sanitize_zips_log << %Q{[#{Time.now.in_time_zone}] Extracting #{f.name}}
        # Obtain File Path
        f_path = File.join(path, f.name)
        # Create Directory
        FileUtils.mkdir_p(File.dirname(f_path))
        # Extract files into the file path
        zip_file.extract(f, f_path) unless File.exist?(f_path)

        # Remove characters in regexes_to_remove from extracted file
        extracted_file_content = File.open(f_path, "r:UTF-8", &:read)

        File.open(f_path, "w:UTF-8") do |f| 

          regexes_to_remove.each do |regex|
            extracted_file_content = extracted_file_content.gsub(regex, '')
          end

          f.write(extracted_file_content)
        end 

        # Reject files that passed the extension test but might be a binary file in disguise
        # if f.file? filepath
        #   extract_and_sanitize_zips_log << %Q{[#{Time.now.in_time_zone}] Detected binary file, deleting #{f.name}}
        #   FileUtils.rm filepath
        # end
      else
        extract_and_sanitize_zips_log << %Q{[#{Time.now.in_time_zone}] Invalid file type, Ignoring #{f.name} with extension #{File.extname(f.name)}}
      end
      }
    }
    
    extract_and_sanitize_zips_log << %Q{[#{Time.now.in_time_zone}] Checking for empty directories}
    bot = ReorgBot.new(path)
    extract_and_sanitize_zips_log << bot.remove_empty_dirs

    return extract_and_sanitize_zips_log
  end

  def self.process_submissions(path, assignment, isMapEnabled, used_fingerprints)
    # Create directory for code comparison, delete first if necessary
    compare_dir = File.join(path, "_compare")
    FileUtils.rm(compare_dir, force: true) if File.exist? compare_dir
    FileUtils.mkdir_p(File.join(path, "_compare"))
    
    # For reference submissions, combine them into a file with file name of form references_{semester name}_{student name}
    # For current sem's submissions, combine them into a file
    Dir.glob(File.join(path, "*")).each { |subpath| 
      if subpath == compare_dir || (File.file?(subpath) && subpath.split('.').last.to_s.downcase == 'csv')
        next
      elsif subpath.include?("/references")
        # Loop over the subfolders (for different semesters) in the /references folder
        Dir.glob(File.join(subpath, '*')).each { |semester_subpath| 
          # For each student in the semester, combine code files into a file named references_{semester name}_{student name}
          # and write into _compare folder
          Dir.glob(File.join(semester_subpath, '*')).each { |student_subpath| 
            File.open(File.join(compare_dir, "references_" + semester_subpath.split('/').last + "_" + student_subpath.split('/').last), 'w') { |f|
              f.puts string_from_combined_files(student_subpath)
            }
          }
        }

        next
      else
        # Combine code files and write into _compare folder as new file with same name
        File.open(File.join(compare_dir, subpath.split('/').last), 'w') { |f|
          f.puts string_from_combined_files(subpath)
        }
      end
    }

    if ApplicationHelper.is_application_healthy()
      puts "Process assignment: #{assignment.id}"
      fork_Java_process(compare_dir, assignment, isMapEnabled, used_fingerprints)
    else 
      puts "Put in queue, assignment: #{assignment.id}"
      SubmissionSimilarityProcess.create do |p|
        p.assignment_id = assignment.id
        p.status = SubmissionSimilarityProcess::STATUS_WAITING
      end
    end
  end

  def self.fork_Java_process(compare_dir, assignment, isMapEnabled, used_fingerprints)
    # Read database configuration
    config   = Rails.configuration.database_configuration
    host     = config[Rails.env]["host"]
    database = config[Rails.env]["database"]
    username = config[Rails.env]["username"]
    password = config[Rails.env]["password"]

    # Run the java program and get its pid
    command = %Q{java -Xmx2048M -Dlog4j2.configurationFile="#{Rails.application.config.plagiarism_detection_log_configuration_path}" -jar "#{Rails.application.config.plagiarism_detection_path}" } + 
              %Q{#{assignment.id} #{compare_dir} #{assignment.language.downcase} } +
              %Q{#{assignment.min_match_length} #{assignment.ngram_size} } +
              %Q{#{host} #{database} #{username} #{password} #{isMapEnabled} #{used_fingerprints}}  
    # Fork to run java program in background
    ruby_pid = Process.fork do
      java_log = ""
      java_status = nil
      Open3.popen2e({ "LD_LIBRARY_PATH" => Rails.application.config.ld_library_path }, command) { |i,o,t|
        java_log << o.gets until o.eof?
        java_status = t.value
      }

      # Update log
      upload_log = []
      upload_log << assignment.upload_log if assignment.upload_log
      upload_log << java_log.truncate(MAX_DATA_CHAR_SIZE, separator: ' ', omission: DATA_TRUNCATE_MSG)
      assignment.upload_log = upload_log.join("\n")
      
      # Update status
      process = assignment.submission_similarity_process
      if java_status.exitstatus == 0
        process.status = SubmissionSimilarityProcess::STATUS_COMPLETED
      else
        process.status = SubmissionSimilarityProcess::STATUS_ERRONEOUS
        puts "Print out log in case of erroneous processing"
        puts java_log
      end

      # Save
      assignment.transaction do
        assignment.save
        process.save
      end
    end

    # Create process with pid
    process = assignment.submission_similarity_process
    if process.nil?
      SubmissionSimilarityProcess.create do |p|
        p.assignment_id = assignment.id
        p.pid = ruby_pid
        p.status = SubmissionSimilarityProcess::STATUS_RUNNING
      end
    else
      process.pid = ruby_pid
      process.status = SubmissionSimilarityProcess::STATUS_RUNNING
      process.save
    end

    Process.detach(ruby_pid) # Parent will not wait
  end

  def self.process_cluster_group(cluster_group)
    # Get assignment
    assignment = cluster_group.assignment

    # Read database configuration
	  config   = Rails.configuration.database_configuration
	  host     = config[Rails.env]["host"]
	  database = config[Rails.env]["database"]
	  username = config[Rails.env]["username"]
	  password = config[Rails.env]["password"]

    # Run the java program and get its pid
    command = %Q{java -Xmx1024M -jar "#{Rails.application.config.submissions_clustering_path}" } + 
              %Q{#{assignment.id} #{cluster_group.id} #{cluster_group.cut_off_criterion} } +
              %Q{#{host} #{database} #{username} #{password} 2>&1}

    java_log = ""
    IO.popen(command) { |pipe|
      java_log << pipe.gets until pipe.eof?
    }
    java_status = $?

    raise "Submissions clustering error: #{java_log}" unless java_status.exitstatus == 0
  end

  private

  def self.string_from_combined_files(path)
    strings = []
    if File.directory? path
      Dir.glob(File.join(path, "*")).sort.each { |subpath|
        strings << string_from_combined_files(subpath)
      }
    else
      # byebug
      if (File.extname(path).include? ".ipynb") then
        convert_to_python(path, strings)
      else
        strings << File.open(path).readlines.join
      end
    end

    strings.join("\n")
  end

  def self.convert_to_python(path, strings)
    # byebug
    path_without_special_chars = path.gsub(/[\s\(\)\*\@\$\%\&\*]/, '__')
    File.rename(path, path_without_special_chars)
    command = "jupyter nbconvert --to script #{path_without_special_chars}"
    isConversionSuccessful = system(command)
    if isConversionSuccessful then
      new_path = path_without_special_chars.gsub(/.ipynb$/, '.py')
      strings << File.open(new_path).readlines.join
    else
      puts "Failed to convert file #{path_without_special_chars} to py"      
    end
  end
end
